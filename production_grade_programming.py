# -*- coding: utf-8 -*-
"""Production Grade Programming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oQmHAP8_LjhctfoQn-d8ycgQ2I1GGlFN

# What is Production Environment?

Production environment is a term used mostly by developers to describe the setting where software and other products are actually put into operation for their intended uses by end users.

Concepts that will be useful in writing production grade code:
* Object Oriented Programming
* Handling Errors and Exceptions

# 1. Object Oriented Programming

Object Oriented Programming (OOP) tends to be one of the most interesting concepts to learn in Python.

For this lesson we will construct our knowledge of OOP in Python by building on the following topics:

* Objects
* Using the *class* keyword
* Creating class attributes
* Creating methods in a class
* Learning about Polymorphism

Lets start the lesson by remembering about the Basic Python Objects. For example:
"""

empty_list = []

empty_list

another_empty_list = list()

another_empty_list

"""Remember how we could call methods on a list?"""

another_empty_list.append(2)

another_empty_list

another_empty_list.append(1)
another_empty_list.append(3)

another_empty_list

another_empty_list.index(3)

"""What we will basically be doing in this lecture is exploring how we could create an Object type like a list. We've already learned about how to create functions. So let's explore Objects in general:

## Objects
In Python, *everything is an object*. Remember from previous lectures we can use type() to check the type of object something is:
"""

the_sixth_sense = 6
print(type(the_sixth_sense))

two_and_a_half_men = 2.5
print(type(two_and_a_half_men))

schindlers_list = list()
print(type(schindlers_list))

another_list = list()

tharoor = {'farrago':'a confused mixture'}
print(type(tharoor))

"""So we know all these things are objects, so how can we create our own Object types? That is where the <code>class</code> keyword comes in.
## class
User defined objects are created using the <code>class</code> keyword. The class is a blueprint that defines the nature of a future object. From classes we can construct instances. An instance is a specific object created from a particular class. For example, above we created the object <code>another_empty_list</code> which was an instance of a list object. 

Let see how we can use <code>class</code>:
"""

# Create a new object type called FirstClass
class FirstClass:
    pass

# Instance of FirstClass
x = FirstClass()
print(type(x))

y = FirstClass()
print(type(y))

"""By convention we give classes a name that starts with a capital letter. Note how <code>x</code> is now the reference to our new instance of a FirstClass class. In other words, we **instantiate** the FirstClass class.

Inside of the class we currently just have pass. But we can define class attributes and methods.

An **attribute** is a characteristic of an object.
A **method** is an operation we can perform with the object.

For example, we can create a class called Dog. An attribute of a dog may be its breed or its name, while a method of a dog may be defined by a .bark() method which returns a sound.

Let's get a better understanding of attributes through an example.

## Attributes
The syntax for creating an attribute is:
    
    self.attribute = something
    
There is a special method called:

    __init__()

This method is used to initialize the attributes of an object. For example:
"""

class Dog:
    
    def __init__(self, breed, name):
        self.breed_attribute = breed
        self.name_attribute = name

sam_object = Dog(breed='Lab', name = 'Sam')
frank_object = Dog(breed='Huskie', name = 'Frank')

sam_object.breed_attribute

"""Lets break down what we have above.The special method 

    __init__() 
is called automatically right after the object has been created:

    def __init__(self, breed):
Each attribute in a class definition begins with a reference to the instance object. It is by convention named self. The breed is the argument. The value is passed during the class instantiation.

     self.breed = breed

Now we have created two instances of the Dog class. With two breed types, we can then access these attributes like this:
"""

sam_object.name_attribute

frank_object.name_attribute

"""Note how we don't have any parentheses after breed; this is because it is an attribute and doesn't take any arguments.

## Methods

Methods are functions defined inside the body of a class. They are used to perform operations with the attributes of our objects. Methods are a key concept of the OOP paradigm. They are essential to dividing responsibilities in programming, especially in large applications.

You can basically think of methods as functions acting on an Object that take the Object itself into account through its *self* argument.

Let's go through an example of creating a Circle class:
"""

class Circle:

  def __init__(self, radius=1):
    self.radius = radius
    self.area = 3.14 * radius * radius

  def setRadius(self, new_radius):
    self.radius = new_radius
    self.area = 3.14 * new_radius * new_radius

  def getCircumference(self):
    return 2 * 3.14 * self.radius

c = Circle()

c.area

c.getCircumference()

print('Radius is: ', c.radius)
print('Area is: ', c.area)
print('Circumference is: ', c.getCircumference())

"""Now let's change the radius and see how that affects our Circle object:"""

c.setRadius(4)

print('Radius is: ', c.radius)
print('Area is: ', c.area)
print('Circumference is: ', c.getCircumference())

"""Great! Notice how we used self. notation to reference attributes of the class within the method calls. Review how the code above works and try creating your own method.

## Polymorphism

We've learned that while functions can take in different arguments, methods belong to the objects they act on. In Python, *polymorphism* refers to the way in which different object classes can share the same method name, and those methods can be called from the same place even though a variety of different objects might be passed in. The best way to explain this is by example:
"""

class HouseStark:
    def __init__(self, sigil):
        self.sigil = sigil

    def motto(self):
        return "House Stark with sigil " + self.sigil + " has the motto 'Winter is coming'"

class HouseLannister:
    def __init__(self, sigil):
        self.sigil = sigil

    def motto(self):
        return "House Lannister with sigil " + self.sigil + " has the motto 'Hear me roar'"

arya = HouseStark('direwolf')
tyrion = HouseLannister('golden lion')

print(arya.motto())

print(tyrion.motto())

"""Here we have a HouseStark class and a HouseLannister class, and each has a `.motto()` method. When called, each object's `.motto()` method returns a result unique to the object.

There a few different ways to demonstrate polymorphism. First, with a for loop:
"""

for warrior in [arya, tyrion]:
    print(warrior.motto())

"""Another is with functions:"""

def get_motto(warrior):
    print(warrior.motto())

get_motto(arya)
get_motto(tyrion)

"""In both cases we were able to pass in different object types, and we obtained object-specific results from the same mechanism.

**Great! By now you should have a basic understanding of how to create your own objects with class in Python.**

# 2. Errors and Exception Handling

Now we will learn about Errors and Exception Handling in Python. You've definitely already encountered errors by this point in the course. For example:
"""

print('XGBoost)

"""Note how we get a SyntaxError, with the further description that it was an EOL (End of Line Error) while scanning the string literal. This is specific enough for us to see that we forgot a single quote at the end of the line. Understanding these various error types will help you debug your code much faster. 

This type of error and description is known as an Exception. Even if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal.

You can check out the full list of built-in exceptions [here](https://docs.python.org/3/library/exceptions.html). Now let's learn how to handle errors and exceptions in our own code.

## try and except

The basic terminology and syntax used to handle errors in Python are the <code>try</code> and <code>except</code> statements. The code which can cause an exception to occur is put in the <code>try</code> block and the handling of the exception is then implemented in the <code>except</code> block of code. The syntax follows:

    try:
       You do your operations here...
       ...
    except:
       If there is an exception, then execute this block.
    else:
       If there is no exception then execute this block. 

To get a better understanding of this let's check out an example:
"""

try:
    print("Good to go!")
    print('a', fwdfdwafwf)
    print('b')
except:
    # This will check for any exception and then execute this print statement
    print("Oops!")
    print('c')
    print('d')
else:
    print("No errors encountered!")
    print('e')
    print('f')

"""Great! Now we don't actually need to memorize that list of exception types! Now what if we kept wanting to run code after the exception occurred? This is where <code>finally</code> comes in.
## finally
The <code>finally:</code> block of code will always be run regardless if there was an exception in the <code>try</code> code block. The syntax is:

    try:
       Code block here
       ...
       Due to any exception, this code may be skipped!
    finally:
       This code block would always be executed.

For example:
"""

try:
  print("Execute try statements")
finally:
  print("Always execute finally code blocks")

"""We can use this in conjunction with <code>except</code>. Let's see a new example that will take into account a user providing the wrong input:"""

a = 1
b = 0.2

try:
    print(afdwfwf, type(aefwffewf))
except:
    print(b, type(b))
finally:
    print('Type printed')

try:
    a = 1
    print(adefewdwd)
    try:
      print(type(afggdgdsgg))
    except:
      print('Error occured')
except Exception as ex:
    print('The error is : ', ex)
    print(b, type(b))

"""**Great! Now you know how to handle errors and exceptions in Python with the try, except, else, and finally notation!**

# Real World Use Case

### Uber's simplified pricing model

When you request an Uber, you enter your pick-up location and the destination. Based on the distance, peak hours, willingness to pay and many other factors, Uber uses a machine learning algorithm to compute what prices will be shown to you.

Let's consider a simplistic version of the Uber Pricing Model where you compute the price based on the distance between the pick-up and the drop location and the time of the booking.

User Inputs:

* Pick-up location (pick_up_latitude, pick_up_longitude)
* Drop location (drop_latitude, drop_longitude)
* Time of booking

Output:

* Final Price

### Development Code
"""

# Calculate the distance between the pick-up location and the drop location

import geopy.distance
        
def get_distance(location_1, location_2):

    distance = geopy.distance.distance(location_1, location_2).km

    return distance

def get_price_per_km(hour):
    
    if (hour > 8) & (hour < 11):
        price_per_km = 20
    elif (hour > 18) & (hour < 21):
        price_per_km = 15
    else:
        price_per_km = 10
        
    return price_per_km

def get_final_price(pick_up_location, drop_location, booking_hour):
    
    total_distance = get_distance(pick_up_location, drop_location)
    actual_price_per_km = get_price_per_km(booking_hour)
    
    final_price = round(total_distance * actual_price_per_km, 2)
    
    return final_price

# Inputs

pick_up_location = (24, 70)
drop_location = (24.1, 70.1)
booking_time = 19

# Output

get_final_price(pick_up_location, drop_location, booking_time)

"""### Production Grade Code"""

# Calculate the distance between the pick-up location and the drop location

import geopy.distance
import math

class Maps:
    
    def __init__(self):
        pass
        
    def get_distance(self, location_1, location_2):

        try:
            distance = geopy.distance.distance(location_1, location_2).km
        except:
            distance = math.sqrt((location_1[0]-location_2[0])^2 + (location_1[1]-location_2[1])^2)
            
        return distance

class SurgePricing:
    
    def __init__(self):
        pass

    def get_price_per_km(self, hour):

        try:

            if (hour > 8) & (hour < 11):
                price_per_km = 20
            elif (hour > 18) & (hour < 21):
                price_per_km = 15
            else:
                price_per_km = 10

        except:

            price_per_km = 10

        return price_per_km

def get_final_price(pick_up_location, drop_location, booking_hour):
    
    maps = Maps()
    surge = SurgePricing()
    
    total_distance = maps.get_distance(pick_up_location, drop_location)
    actual_price_per_km = surge.get_price_per_km(booking_hour)
    
    final_price = round(total_distance * actual_price_per_km, 2)
    
    return final_price

# Output

get_final_price(pick_up_location, drop_location, booking_time)



